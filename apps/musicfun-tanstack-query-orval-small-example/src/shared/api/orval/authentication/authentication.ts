/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * MusicFun API
 * API for learning. Create your own analogue of a popular music service, such as SoundCloud or Spotify.

<h4>mp3 examples:</h4> 
üîà: https://musicfun.it-incubator.app/api/samurai-way-soundtrack.mp3   
üîà: https://musicfun.it-incubator.app/api/samurai-way-soundtrack-instrumental.mp3
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  AuthControllerOauthRedirectParams,
  BadRequestException,
  GetMeOutput,
  LoginRequestPayload,
  LogoutRequestPayload,
  RefreshOutput,
  RefreshRequestPayload,
  UnauthorizedException,
} from '../musicfun.schemas'

import { customInstance } from '.././custom-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * The callback URL to redirect after granting access, <a target="_blank" href="https://oauth.apihub.it-incubator.io/realms/apihub/protocol/openid-connect/auth?client_id=musicfun&response_type=code&redirect_uri=http://localhost:3000/oauth2/callback&scope=openid">https://oauth.apihub.it-incubator.io/realms/apihub/protocol/openid-connect/auth?client_id=musicfun&response_type=code&redirect_uri=http://localhost:3000/oauth2/callback&scope=openid</a>
 * @summary OAuth redirect
 */
export const authControllerOauthRedirect = (
  params: AuthControllerOauthRedirectParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<null>({ url: `/auth/oauth-redirect`, method: 'GET', params, signal }, options)
}

export const getAuthControllerOauthRedirectQueryKey = (params?: AuthControllerOauthRedirectParams) => {
  return [`/auth/oauth-redirect`, ...(params ? [params] : [])] as const
}

export const getAuthControllerOauthRedirectQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerOauthRedirect>>,
  TError = unknown,
>(
  params: AuthControllerOauthRedirectParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerOauthRedirect>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAuthControllerOauthRedirectQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerOauthRedirect>>> = ({ signal }) =>
    authControllerOauthRedirect(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerOauthRedirect>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerOauthRedirectQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerOauthRedirect>>
>
export type AuthControllerOauthRedirectQueryError = unknown

export function useAuthControllerOauthRedirect<
  TData = Awaited<ReturnType<typeof authControllerOauthRedirect>>,
  TError = unknown,
>(
  params: AuthControllerOauthRedirectParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerOauthRedirect>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerOauthRedirect>>,
          TError,
          Awaited<ReturnType<typeof authControllerOauthRedirect>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerOauthRedirect<
  TData = Awaited<ReturnType<typeof authControllerOauthRedirect>>,
  TError = unknown,
>(
  params: AuthControllerOauthRedirectParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerOauthRedirect>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerOauthRedirect>>,
          TError,
          Awaited<ReturnType<typeof authControllerOauthRedirect>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerOauthRedirect<
  TData = Awaited<ReturnType<typeof authControllerOauthRedirect>>,
  TError = unknown,
>(
  params: AuthControllerOauthRedirectParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerOauthRedirect>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary OAuth redirect
 */

export function useAuthControllerOauthRedirect<
  TData = Awaited<ReturnType<typeof authControllerOauthRedirect>>,
  TError = unknown,
>(
  params: AuthControllerOauthRedirectParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerOauthRedirect>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerOauthRedirectQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Log in using the code received after OAuth authorization redirect
 */
export const authControllerLogin = (
  loginRequestPayload: LoginRequestPayload,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RefreshOutput>(
    {
      url: `/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginRequestPayload,
      signal,
    },
    options,
  )
}

export const getAuthControllerLoginMutationOptions = <
  TError = BadRequestException | UnauthorizedException,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLogin>>,
    TError,
    { data: LoginRequestPayload },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerLogin>>,
  TError,
  { data: LoginRequestPayload },
  TContext
> => {
  const mutationKey = ['authControllerLogin']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogin>>, { data: LoginRequestPayload }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return authControllerLogin(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AuthControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
export type AuthControllerLoginMutationBody = LoginRequestPayload
export type AuthControllerLoginMutationError = BadRequestException | UnauthorizedException

/**
 * @summary Log in using the code received after OAuth authorization redirect
 */
export const useAuthControllerLogin = <TError = BadRequestException | UnauthorizedException, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerLogin>>,
      TError,
      { data: LoginRequestPayload },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerLogin>>,
  TError,
  { data: LoginRequestPayload },
  TContext
> => {
  const mutationOptions = getAuthControllerLoginMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Refresh refresh/access token pair
 */
export const authControllerRefresh = (
  refreshRequestPayload: RefreshRequestPayload,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RefreshOutput>(
    {
      url: `/auth/refresh`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: refreshRequestPayload,
      signal,
    },
    options,
  )
}

export const getAuthControllerRefreshMutationOptions = <TError = UnauthorizedException, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRefresh>>,
    TError,
    { data: RefreshRequestPayload },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerRefresh>>,
  TError,
  { data: RefreshRequestPayload },
  TContext
> => {
  const mutationKey = ['authControllerRefresh']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRefresh>>,
    { data: RefreshRequestPayload }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerRefresh(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AuthControllerRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRefresh>>>
export type AuthControllerRefreshMutationBody = RefreshRequestPayload
export type AuthControllerRefreshMutationError = UnauthorizedException

/**
 * @summary Refresh refresh/access token pair
 */
export const useAuthControllerRefresh = <TError = UnauthorizedException, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerRefresh>>,
      TError,
      { data: RefreshRequestPayload },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerRefresh>>,
  TError,
  { data: RefreshRequestPayload },
  TContext
> => {
  const mutationOptions = getAuthControllerRefreshMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Deactivate refresh token
 */
export const authControllerLogout = (
  logoutRequestPayload: LogoutRequestPayload,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<null>(
    {
      url: `/auth/logout`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: logoutRequestPayload,
      signal,
    },
    options,
  )
}

export const getAuthControllerLogoutMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLogout>>,
    TError,
    { data: LogoutRequestPayload },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerLogout>>,
  TError,
  { data: LogoutRequestPayload },
  TContext
> => {
  const mutationKey = ['authControllerLogout']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLogout>>,
    { data: LogoutRequestPayload }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerLogout(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>
export type AuthControllerLogoutMutationBody = LogoutRequestPayload
export type AuthControllerLogoutMutationError = unknown

/**
 * @summary Deactivate refresh token
 */
export const useAuthControllerLogout = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerLogout>>,
      TError,
      { data: LogoutRequestPayload },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerLogout>>,
  TError,
  { data: LogoutRequestPayload },
  TContext
> => {
  const mutationOptions = getAuthControllerLogoutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get current user by access token
 */
export const authControllerGetMe = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<GetMeOutput>({ url: `/auth/me`, method: 'GET', signal }, options)
}

export const getAuthControllerGetMeQueryKey = () => {
  return [`/auth/me`] as const
}

export const getAuthControllerGetMeQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerGetMe>>,
  TError = null,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGetMeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetMe>>> = ({ signal }) =>
    authControllerGetMe(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerGetMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerGetMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetMe>>>
export type AuthControllerGetMeQueryError = null

export function useAuthControllerGetMe<TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = null>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetMe>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetMe<TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = null>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetMe>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetMe<TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = null>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user by access token
 */

export function useAuthControllerGetMe<TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = null>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerGetMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}
