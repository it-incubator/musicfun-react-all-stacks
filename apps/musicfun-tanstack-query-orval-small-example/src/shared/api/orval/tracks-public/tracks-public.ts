/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * MusicFun API
 * API for learning. Create your own analogue of a popular music service, such as SoundCloud or Spotify.

<h4>mp3 examples:</h4> 
üîà: https://musicfun.it-incubator.app/api/samurai-way-soundtrack.mp3   
üîà: https://musicfun.it-incubator.app/api/samurai-way-soundtrack-instrumental.mp3
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  GetPlaylistTrackListOutput,
  GetTrackDetailsOutput,
  GetTrackListOutput,
  JsonApiErrorDocument,
  ReactionOutput,
  TracksPublicControllerGetAllTracksParams,
} from '../musicfun.schemas'

import { customInstance } from '.././custom-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * @summary Get list of all tracks in all playlists
 */
export const tracksPublicControllerGetAllTracks = (
  params?: TracksPublicControllerGetAllTracksParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTrackListOutput>({ url: `/playlists/tracks`, method: 'GET', params, signal }, options)
}

export const getTracksPublicControllerGetAllTracksQueryKey = (params?: TracksPublicControllerGetAllTracksParams) => {
  return [`/playlists/tracks`, ...(params ? [params] : [])] as const
}

export const getTracksPublicControllerGetAllTracksQueryOptions = <
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>,
  TError = JsonApiErrorDocument,
>(
  params?: TracksPublicControllerGetAllTracksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTracksPublicControllerGetAllTracksQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>> = ({ signal }) =>
    tracksPublicControllerGetAllTracks(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TracksPublicControllerGetAllTracksQueryResult = NonNullable<
  Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>
>
export type TracksPublicControllerGetAllTracksQueryError = JsonApiErrorDocument

export function useTracksPublicControllerGetAllTracks<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>,
  TError = JsonApiErrorDocument,
>(
  params: undefined | TracksPublicControllerGetAllTracksParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>,
          TError,
          Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTracksPublicControllerGetAllTracks<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>,
  TError = JsonApiErrorDocument,
>(
  params?: TracksPublicControllerGetAllTracksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>,
          TError,
          Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTracksPublicControllerGetAllTracks<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>,
  TError = JsonApiErrorDocument,
>(
  params?: TracksPublicControllerGetAllTracksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get list of all tracks in all playlists
 */

export function useTracksPublicControllerGetAllTracks<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>,
  TError = JsonApiErrorDocument,
>(
  params?: TracksPublicControllerGetAllTracksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetAllTracks>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTracksPublicControllerGetAllTracksQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get list of tracks in a playlist
 */
export const tracksPublicControllerGetPlaylistTracks = (
  playlistId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetPlaylistTrackListOutput>(
    { url: `/playlists/${playlistId}/tracks`, method: 'GET', signal },
    options,
  )
}

export const getTracksPublicControllerGetPlaylistTracksQueryKey = (playlistId?: string) => {
  return [`/playlists/${playlistId}/tracks`] as const
}

export const getTracksPublicControllerGetPlaylistTracksQueryOptions = <
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>,
  TError = null,
>(
  playlistId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTracksPublicControllerGetPlaylistTracksQueryKey(playlistId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>> = ({ signal }) =>
    tracksPublicControllerGetPlaylistTracks(playlistId, requestOptions, signal)

  return { queryKey, queryFn, enabled: !!playlistId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TracksPublicControllerGetPlaylistTracksQueryResult = NonNullable<
  Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>
>
export type TracksPublicControllerGetPlaylistTracksQueryError = null

export function useTracksPublicControllerGetPlaylistTracks<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>,
  TError = null,
>(
  playlistId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>,
          TError,
          Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTracksPublicControllerGetPlaylistTracks<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>,
  TError = null,
>(
  playlistId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>,
          TError,
          Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTracksPublicControllerGetPlaylistTracks<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>,
  TError = null,
>(
  playlistId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get list of tracks in a playlist
 */

export function useTracksPublicControllerGetPlaylistTracks<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>,
  TError = null,
>(
  playlistId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetPlaylistTracks>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTracksPublicControllerGetPlaylistTracksQueryOptions(playlistId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get track details by ID
 */
export const tracksPublicControllerGetTrackDetails = (
  trackId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTrackDetailsOutput>({ url: `/playlists/tracks/${trackId}`, method: 'GET', signal }, options)
}

export const getTracksPublicControllerGetTrackDetailsQueryKey = (trackId?: string) => {
  return [`/playlists/tracks/${trackId}`] as const
}

export const getTracksPublicControllerGetTrackDetailsQueryOptions = <
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>,
  TError = null,
>(
  trackId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTracksPublicControllerGetTrackDetailsQueryKey(trackId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>> = ({ signal }) =>
    tracksPublicControllerGetTrackDetails(trackId, requestOptions, signal)

  return { queryKey, queryFn, enabled: !!trackId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TracksPublicControllerGetTrackDetailsQueryResult = NonNullable<
  Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>
>
export type TracksPublicControllerGetTrackDetailsQueryError = null

export function useTracksPublicControllerGetTrackDetails<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>,
  TError = null,
>(
  trackId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>,
          TError,
          Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTracksPublicControllerGetTrackDetails<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>,
  TError = null,
>(
  trackId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>,
          TError,
          Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTracksPublicControllerGetTrackDetails<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>,
  TError = null,
>(
  trackId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get track details by ID
 */

export function useTracksPublicControllerGetTrackDetails<
  TData = Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>,
  TError = null,
>(
  trackId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tracksPublicControllerGetTrackDetails>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTracksPublicControllerGetTrackDetailsQueryOptions(trackId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Like or toggle like on a track
 */
export const tracksPublicControllerLikeTrack = (
  trackId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ReactionOutput>({ url: `/playlists/tracks/${trackId}/likes`, method: 'POST', signal }, options)
}

export const getTracksPublicControllerLikeTrackMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tracksPublicControllerLikeTrack>>,
    TError,
    { trackId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tracksPublicControllerLikeTrack>>,
  TError,
  { trackId: string },
  TContext
> => {
  const mutationKey = ['tracksPublicControllerLikeTrack']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tracksPublicControllerLikeTrack>>,
    { trackId: string }
  > = (props) => {
    const { trackId } = props ?? {}

    return tracksPublicControllerLikeTrack(trackId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TracksPublicControllerLikeTrackMutationResult = NonNullable<
  Awaited<ReturnType<typeof tracksPublicControllerLikeTrack>>
>

export type TracksPublicControllerLikeTrackMutationError = null | null | null

/**
 * @summary Like or toggle like on a track
 */
export const useTracksPublicControllerLikeTrack = <TError = null | null | null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tracksPublicControllerLikeTrack>>,
      TError,
      { trackId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tracksPublicControllerLikeTrack>>,
  TError,
  { trackId: string },
  TContext
> => {
  const mutationOptions = getTracksPublicControllerLikeTrackMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Dislike or toggle dislike on a track
 */
export const tracksPublicControllerDislikeTrack = (
  trackId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ReactionOutput>(
    { url: `/playlists/tracks/${trackId}/dislikes`, method: 'POST', signal },
    options,
  )
}

export const getTracksPublicControllerDislikeTrackMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tracksPublicControllerDislikeTrack>>,
    TError,
    { trackId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tracksPublicControllerDislikeTrack>>,
  TError,
  { trackId: string },
  TContext
> => {
  const mutationKey = ['tracksPublicControllerDislikeTrack']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tracksPublicControllerDislikeTrack>>,
    { trackId: string }
  > = (props) => {
    const { trackId } = props ?? {}

    return tracksPublicControllerDislikeTrack(trackId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TracksPublicControllerDislikeTrackMutationResult = NonNullable<
  Awaited<ReturnType<typeof tracksPublicControllerDislikeTrack>>
>

export type TracksPublicControllerDislikeTrackMutationError = null | null | null

/**
 * @summary Dislike or toggle dislike on a track
 */
export const useTracksPublicControllerDislikeTrack = <TError = null | null | null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tracksPublicControllerDislikeTrack>>,
      TError,
      { trackId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tracksPublicControllerDislikeTrack>>,
  TError,
  { trackId: string },
  TContext
> => {
  const mutationOptions = getTracksPublicControllerDislikeTrackMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Remove user reaction from a track
 */
export const tracksPublicControllerRemoveTrackReaction = (
  trackId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ReactionOutput>({ url: `/playlists/tracks/${trackId}/reactions`, method: 'DELETE' }, options)
}

export const getTracksPublicControllerRemoveTrackReactionMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tracksPublicControllerRemoveTrackReaction>>,
    TError,
    { trackId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tracksPublicControllerRemoveTrackReaction>>,
  TError,
  { trackId: string },
  TContext
> => {
  const mutationKey = ['tracksPublicControllerRemoveTrackReaction']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tracksPublicControllerRemoveTrackReaction>>,
    { trackId: string }
  > = (props) => {
    const { trackId } = props ?? {}

    return tracksPublicControllerRemoveTrackReaction(trackId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TracksPublicControllerRemoveTrackReactionMutationResult = NonNullable<
  Awaited<ReturnType<typeof tracksPublicControllerRemoveTrackReaction>>
>

export type TracksPublicControllerRemoveTrackReactionMutationError = null

/**
 * @summary Remove user reaction from a track
 */
export const useTracksPublicControllerRemoveTrackReaction = <TError = null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tracksPublicControllerRemoveTrackReaction>>,
      TError,
      { trackId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tracksPublicControllerRemoveTrackReaction>>,
  TError,
  { trackId: string },
  TContext
> => {
  const mutationOptions = getTracksPublicControllerRemoveTrackReactionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
